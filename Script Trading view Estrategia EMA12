// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © codetradesolutions

//@version=5
indicator("Risk ! [CTS]", overlay = true, precision=4, linktoseries=true, max_bars_back=1000, max_lines_count=500)

ticker = syminfo.ticker
tema           = input.string("Oscuro", title="Tema", options = ["Oscuro", "Claro"], group = ' ======== !!! CUADRO DE DATOS !!! ======== ')
string tam = 'modifica el tamaño del cuadro de datos'
i_textSize   = input.string('Small', 'Text Size', options=['Tiny', 'Small', 'Normal', 'Large'], tooltip = tam, group = ' ======== !!! CUADRO DE DATOS !!! ======== ')
textSize     = i_textSize == 'Small' ? size.small : i_textSize == 'Normal' ? size.normal : i_textSize == 'Large' ? size.large : size.tiny


config_cuenta       = '💸💸 Configuracion de cuenta / Calculo de riesgo 💸💸'
string capital1 = 'dinero distinado a la cuenta de futuros'
capital             = input.float(100, title = "Capital inicial:  U$DT 💲",minval = 0, step = 0.05,tooltip = capital1,group = config_cuenta)
string riesgo = 'porcentaje de la cuenta a perder en caso de que el trade se vaya a stop loss'
perdida_            = input.float(1, title = "Riesgo asumido sobre el total de la cuenta:    %",minval = 0, step = 0.05,tooltip = riesgo,group = config_cuenta )
string comi = 'comision  por apertura y cierre de una operacion, se recomienda consultar la tabla de comisiones del exchange. abrir y cerrar los trades siempre a limit. nunca a market'
comision            = input.float(0.08, title="Comision Apertura + Cierre",  minval = 0.01, maxval = 0.2,step= 0.005,tooltip = comi, group = config_cuenta)
take_profit         = input.float(1.7, title = "RATIO TAKE PROFIT (RR) % 💰", step = 0.1, group =config_cuenta)
string manual = 'seleccionar la opcion manual desde el menu estrategias para poder calcular el lotaje manualmente'
var limit           = input.float(0, title = "ENTRADA (limit)",minval = 0, step = 0.05,tooltip = manual, group = "********** Parametros manuales **********" )
var stop            = input.float(0, title = "STOP LOSS 🛑 ",minval = 0, step = 0.05,tooltip = manual, group = "********** Parametros manuales **********")
string decim = 'cantidad de decimales a mostrar en el cuadro de datos'
DEC                 = input.int(5, title = "DECIMALES",minval = 0, step = 1, tooltip = decim, group = ' ======== !!! CUADRO DE DATOS !!! ======== ' )
var sesa_range = false
var pupupu= false
rsifilter         = false
sz = "🪙🪙🪙🪙🪙🪙 ESTRATEGIA DEL RETO S/Z 🪙🪙🪙🪙🪙🪙"
estrategia             = input.string("PUPUPU", title='<<<<<<<<< Seleccione Estrategia >>>>>>>>>', options = ["PUPUPU", "PUPUPU+FILTROS","La Caja", "MANUAL"], group = "========== ZONA DE ESTRATEGIAS ==========")
TPC              = input(true, title='mostrar zona de profit',     group = sz)


tsr               = input(true, title='Soportes y Resistencias',group = sz)
color_resistencia= input(color.rgb(110, 1, 100),title = "RESISTENCIA", inline='COLOR',    group = sz)
color_soporte = input(color.rgb(110, 1, 100), title =  "SOPORTE", inline='COLOR',    group = sz)

string Minutos              = 'Este valor indica el numero de minutos que dura el Rango para calcular el High y Low'
SML_Channel_TF_mins_D_W_M   = input('400', title="Minutos SML", inline = 'minutos',tooltip = Minutos,group = sz)

if estrategia == "PUPUPU"
    pupupu := true
    sesa_range :=false
if estrategia == "PUPUPU+FILTROS"
    pupupu := true
    rsifilter:=true
    tsr:=true
    sesa_range :=false

if estrategia == "La Caja"
    sesa_range:= true
    pupupu :=false
    tsr := false
if estrategia == "MANUAL"
    sesa_range:=false
    pupupu:= false
    tsr:= true
// Cálculo de Pivotes
M_HIGH  = request.security(syminfo.tickerid, SML_Channel_TF_mins_D_W_M, high, lookahead=barmerge.lookahead_on)
M_LOW   = request.security(syminfo.tickerid, SML_Channel_TF_mins_D_W_M, low, lookahead=barmerge.lookahead_on)
M_MED   = M_LOW+(M_HIGH-M_LOW)/2
M_MEDH  = M_MED + (M_HIGH - M_MED) / 2
M_MEDL  = M_LOW + (M_MED - M_LOW) / 2

plot(not tsr ? na : M_HIGH, title='Resistencia', color=M_HIGH != M_HIGH[1] ? na :color_resistencia , style=plot.style_line, linewidth=2)
plot(not tsr ? na : M_LOW,  title='Soporte',   color=M_LOW  != M_LOW[1]  ? na : color_soporte, style=plot.style_line, linewidth=2)
plot(not tsr ? na : M_MED, title='50%', color=M_LOW != M_LOW[1] ? na : color.rgb(111, 111, 111), style=plot.style_line, linewidth=1)
//plot(not tsr ? na : M_MEDH, title='75%', color=M_LOW != M_LOW[1] ? na : color.rgb(111, 111, 111), style=plot.style_line, linewidth=1)
//plot(not tsr ? na : M_MEDL, title='25 %', color=M_LOW != M_LOW[1] ? na : color.rgb(111, 111, 111), style=plot.style_line, linewidth=1)



//////////////////////////////////////////RSI/////////////////////////////////////////
srcm = close
rsi = ta.rsi(srcm, 14)
sobrecompra = input(70,"ingresar valor para sobrecompra",group = "🛠️🛠️🛠️🛠️CONFIGURACION RSI (filtro PUPUPU)🛠️🛠️🛠️🛠️")
sobreventa = input(30,"ingresar valor para sobreventa", group = "🛠️🛠️🛠️🛠️CONFIGURACION RSI (filtro PUPUPU)🛠️🛠️🛠️🛠️")
sc = rsi > sobrecompra
sv = rsi < sobreventa

rsi_alcista = rsi[1] < sobreventa or rsi[2] < sobreventa or rsi[3] < sobreventa or rsi[4] < sobreventa or rsi[5] < sobreventa or rsi[6] < sobreventa or rsi[7] < sobreventa  
rsi_bajista = rsi[1] > sobrecompra or rsi[2] > sobrecompra or rsi[3] > sobrecompra or rsi[4] > sobrecompra or rsi[5] > sobrecompra or rsi[6] > sobrecompra or rsi[7] > sobrecompra

//////////////////////////////////////// pupupu ///////////////////////////////////////

len = input.int(12, minval=1, title="EMA Estrategia",inline = 'EMACOLOR' ,group= sz)
emacolor =input (color.rgb(223, 223, 219),title="Color", inline='EMACOLOR',group= sz)

ema1 = ta.ema(close, len)
plot(not pupupu ? na : ema1, color= emacolor,title = "ema estrategia", linewidth=1,style=plot.style_stepline)


soporte       = ((low  <= M_LOW  or low[1]  <= M_LOW  or low[2]  <= M_LOW  or low[3]  <= M_LOW  or low[4]  <= M_LOW  or low[5]  <= M_LOW  or low[6]  <= M_LOW  or low[7]  <= M_LOW  or low[8]  <= M_LOW  or low[9]  <= M_LOW  or low[10]  <= M_LOW  or low[11]  <= M_LOW  or low[12]  <= M_LOW  or low[13]  <= M_LOW  or low[14]  <= M_LOW  or low[15]  <= M_LOW)      and (ta.crossover(close, ema1) and (close[1] < ema1[1]) and  (close[2] < ema1[2] and close[3] < ema1[3] and close[4] < ema1[4]) or ( low[1]  <= M_LOW) or low[2]  <= M_LOW) and     (ta.crossover(close, ema1)))// and close[1] < ema1[1]))
resistencia   = ((high >= M_HIGH or high[1] >= M_HIGH or high[2] >= M_HIGH or high[3] >= M_HIGH or high[4] >= M_HIGH or high[5] >= M_HIGH or high[6] >= M_HIGH or high[7] >= M_HIGH or high[8] >= M_HIGH or high[9] >= M_HIGH or high[10] >= M_HIGH or high[11] >= M_HIGH or high[12] >= M_HIGH or high[13] >= M_HIGH or high[14] >= M_HIGH or high[15] >= M_HIGH)     and (ta.crossunder(close, ema1)and (close[1] > ema1[1]) and  (close[2] > ema1[2] and close[3] > ema1[3] and close[4] > ema1[4]) or ( high[1] >= M_HIGH) or high[2] >= M_HIGH) and    (ta.crossunder(close, ema1)))//and close[1] > ema1[1]))
filtro_long   = ema1 < M_MED
filtro_short  = ema1 > M_MED



//////////////////////////////////////////// auxiliares /////////////////////////////////////////////////////////////////////
groupemas                                                                               = "✅✅✅✅ INDICADORES COMPLEMENTARIOS (EMA) ✅✅✅✅"
aux1        = input(false, title='EMA 1',                       inline = 'ema1',group =  groupemas) 
ema1_length = input.int(defval=50,title='', minval=1,           inline = 'ema1',group = groupemas)
aux2        = input(false, title='EMA 2', inline = 'ema2'  ,                    group = groupemas)
ema2_length = input.int(defval=100,title='', minval=1,          inline='ema2' , group = groupemas)
aux3        = input(false, title='EMA 3',  inline = 'ema3'   ,                  group = groupemas)
ema3_length = input.int(defval=200,title='' ,minval=1,          inline = 'ema3',group = groupemas)
string curs = ' en caso de activarse muestra en el grafico el cruce entre la ema1 y la ema2'
cruces      = input(false, title='cruce de EMA 1 con EMA 2', tooltip = curs,    group = groupemas)
// Calculamos las medias móviles
verde = ta.ema(close, ema1_length)
amarilla = ta.ema(close, ema2_length)
roja = ta.ema(close, ema3_length)
ema1color   = input(color.rgb(26, 254, 6, 3),title = 'Color',inline = 'ema1',group = groupemas)
ema2color   = input(color.rgb(248, 229, 55),title = 'Color', inline='ema2',  group = groupemas)
ema3color   = input(color.rgb(231, 12, 12),title = 'Color',  inline='ema3',  group = groupemas)

// Dibujamos las medias móviles
plot(not aux1 ? na : verde, color=ema1color,linewidth=1)
plot(not aux2 ? na : amarilla, color=ema2color, linewidth=1)
plot(not aux3 ? na : roja, color=ema3color, linewidth=1)


vw_ =  "✅✅✅✅✅✅✅✅ VWAP ✅✅✅✅✅✅✅✅"
vw              = input(false, title='VWAP',                                    group = vw_)


////////////////////////// VWAP ////////////////////////////
var anchor = input.string(defval = "Session", title="Anchor Period",options=["Session", "Week", "Month", "Quarter", "Year", "Decade", "Century", "Earnings", "Dividends", "Splits"], group = vw_)
srcv = input(title = "Source", defval = hlc3, group= vw_)
offset = input(0, title="Offset", group= vw_)
if barstate.islast and ta.cum(volume) == 0
    runtime.error("No volume is provided by the data vendor.")
new_earnings = request.earnings(syminfo.tickerid, earnings.actual, barmerge.gaps_on, barmerge.lookahead_on, ignore_invalid_symbol=true)
new_dividends = request.dividends(syminfo.tickerid, dividends.gross, barmerge.gaps_on, barmerge.lookahead_on, ignore_invalid_symbol=true)
new_split = request.splits(syminfo.tickerid, splits.denominator, barmerge.gaps_on, barmerge.lookahead_on, ignore_invalid_symbol=true)
isNewPeriod = switch anchor
	"Earnings"  => not na(new_earnings)
	"Dividends" => not na(new_dividends)
	"Splits"    => not na(new_split)
	"Session"   => timeframe.change("D")
	"Week"      => timeframe.change("W")
	"Month"     => timeframe.change("M")
	"Quarter"   => timeframe.change("3M")
	"Year"      => timeframe.change("12M")
	"Decade"    => timeframe.change("12M") and year % 10 == 0
	"Century"   => timeframe.change("12M") and year % 100 == 0
	=> false
isEsdAnchor = anchor == "Earnings" or anchor == "Dividends" or anchor == "Splits"
if na(srcv[1]) and not isEsdAnchor
	isNewPeriod := true
float vwapValue = na
if not (timeframe.isdwm)
    [_vwap, _stdevUpper, _] = ta.vwap(srcv, isNewPeriod, 1)
	vwapValue := _vwap
    stdevAbs = _stdevUpper - _vwap
plot(not vw ? na : vwapValue, title="VWAP", color=#fbfbfb, offset=offset,linewidth=2)
/////////////////////////////////////////////////////////////// parametros para operacion ///////////////////////////////////
longcondicion= soporte 
shortcondicion= resistencia 
//////////////////////////////////////////////////////////////////////////////////////////////
var limitl = 0.0
var stopl = 0.0
var tpl=0.0
var limits = 0.0
var stops = 0.0
var tps=0.0

var tp = limit + (limit - stop) * take_profit
if rsifilter == true
    if longcondicion and pupupu and rsi_alcista
        limit :=ema1
        limitl:=limit
        limits:=0.0
        stop:= M_LOW
        stopl:=stop
        stops:=0.0
        tp := limit + (limit - stop) * take_profit
        tpl:=tp
        tps:=0.0

    if shortcondicion and pupupu and rsi_bajista
        limit:= ema1
        limits:=limit
        limitl:=0.0
        stop:= M_HIGH
        stops:=stop
        stopl:=0.0
        tp := limit + (limit - stop) * take_profit
        tps:=tp
        tpl:=0.0
if rsifilter == false        
    if longcondicion and pupupu 
        limit :=ema1
        limitl :=limit
        limits := 0.0
        stop := M_LOW
        stopl:=stop
        stops:=0.0
        tp := limit + (limit - stop) * take_profit
        tpl:=tp
        tps:=0.0

    if shortcondicion and pupupu// and filtro_short
        limit:= ema1
        limits:=limit
        limitl:=0.0
        stop:= M_HIGH
        stops:=stop
        stopl:=0.0
        tp := limit + (limit - stop) * take_profit
        tps:=tp
        tpl :=0.0

var perdida = (perdida_* capital ) /100
var RR = "RR 1:"
var op ="na"
var cien = 0
if limit < stop
    op  := "SHORT"
    cien:=-1

if limit > stop
    op := "LONG"
    cien :=1
diferencia = limit - stop
PORCENTT = ((diferencia * 100) / limit)* cien
POSICION = ((100 / PORCENTT) * perdida)
LOTE = POSICION / limit
COMI = ((comision * POSICION)/100)* -1

//////////////////////////////////////////////// MODULO SHORT /////////////////////////////////////////////////
// controlamos que el short llegue a tp
if  low <= tp
    limits:=0.0
    tps:=0.0
    stops:=0.0
// controlamos que el short llegue a stop
if high>=stop
    limits:=0.0
    tps:=0.0
    stops:=0.0

////////////////////////////////////// MODULO LONG ///////////////////////////////////////
// controlamos que el long llegue a tp
if  high >= tp
    limitl:=0.0
    tpl:=0.0
    stopl:=0.0
// controlamos que el long llegue a stop
if low <= stop
    limitl:=0.0
    tpl:=0.0
    stopl:=0.0
/////////////////////////////////////////////// parametros para cruce de emas ////////////////////////
//Cross detect
cross_01_up = ta.crossover(verde, amarilla)
cross_01_down = ta.crossunder(verde, amarilla)
//Wenn cross dann cross  auf ema-level zeichnen
plot(cruces and (cross_01_up or cross_01_down) ? verde : na, style=plot.style_cross, title='cross', linewidth=3, color=verde > amarilla ? color.green : color.red)
//Wenn cross, cross mit Text unten auf chart zeichnen
plotchar(cruces and (cross_01_up or cross_01_down) ? verde : na, title='cross', char='x', location=location.bottom, color=verde > amarilla ? color.green : color.red, text='Cross', textcolor=verde > amarilla ? color.green : color.red)
//Cross2 detect
//publicidad
mysite          = "N-Trade"
var infoTable   = table.new(position = position.bottom_right, columns = 1, rows = 7, bgcolor = color.rgb(208, 207, 198), border_width =2)
table.cell(infoTable, 0, 0, text = mysite,text_halign = text.align_center,                                                               text_size = textSize,text_color  =  chart.bg_color, bgcolor = chart.fg_color)
table.cell(infoTable, 0, 1, text = str.tostring(op) +" "+ticker+"▐"+" " +RR + str.tostring(take_profit),                                 text_size = textSize,text_halign = text.align_left,text_color = color.fuchsia ,bgcolor = chart.bg_color)
table.cell(infoTable, 0, 2, text = "ENTRADA : " + str.tostring(math.round((limit),DEC)),                                                 text_size = textSize,text_halign = text.align_left,text_color = color.yellow, bgcolor = chart.bg_color)
table.cell(infoTable, 0, 3, text = "STOP    : " + str.tostring(math.round((stop),DEC)),                                                  text_size = textSize,text_halign = text.align_left,text_color = color.red ,bgcolor = chart.bg_color)
table.cell(infoTable, 0, 4, text = "TP-1    : " + str.tostring(math.round((tp),DEC)),                                                    text_size = textSize,text_halign = text.align_left, text_color = color.green ,bgcolor = chart.bg_color)
//table.cell(infoTable, 0, 5, text = "LOTE : " + str.tostring(math.round((LOTE),5))+"▐"+ " $ "+ str.tostring(math.round((POSICION),2)),    text_size = textSize,text_halign = text.align_left,text_color = tema == "Oscuro"? color.rgb(250, 250, 250):color.rgb(0, 0, 0) ,bgcolor = chart.bg_color)
//table.cell(infoTable, 0, 6, text = "COMISION: " +"▐ "+str.tostring(math.round((COMI),4))+" ▐ ",                                          text_size = textSize,text_halign = text.align_left,text_color  = tema == "Oscuro"? color.rgb(250, 250, 250):color.rgb(0, 0, 0) ,bgcolor = chart.bg_color)

// impresion de los parametros del corto
medios= plot (not pupupu or limits <= 0.0  ? na : limits , style=plot.style_cross, color= color.rgb(251, 251, 90),linewidth=1)
ganancias= plot (not TPC or tps <= 0.0 ? na : tps , style=plot.style_cross, color= color.rgb(0, 240, 52, 90),linewidth=1)
perdidas= plot (not TPC or stops <= 0.0 ? na : stops , style=plot.style_cross, color= color.rgb(240, 0, 0, 90),linewidth=1)
fill(medios,ganancias,color = color.new(#115440, 65))
fill(medios,perdidas, color = color.new(#e02a2a, 85))

// impresion de los parametros del largo
mediol= plot (not pupupu or limitl <= 0.0 ? na : limitl , style=plot.style_cross, color= color.rgb(251, 251, 90),linewidth=1)
ganancial= plot (not TPC or tpl <= 0.0 ? na : tpl , style=plot.style_cross, color= color.rgb(0, 240, 52, 90),linewidth=1)
perdidal= plot (not TPC or stopl <= 0.0? na : stopl , style=plot.style_cross, color= color.rgb(240, 0, 0, 90),linewidth=1)
fill(mediol,ganancial, color = color.new(#115440, 65))
fill(mediol,perdidal, color = color.new(#e02a2a, 85))

plotshape(not rsifilter ? na :sc, style=shape.triangledown, location=location.top, color=color.red, size=size.tiny)
plotshape(not rsifilter ? na :sv, style=shape.triangleup, location=location.bottom, color=color.green, size=size.tiny)

alertcondition(longcondicion or shortcondicion, title='1- posible trade', message = "1- posible trade {{ticker}}")
alertcondition(cross_01_up, title='2- cross_up', message='es un simple script, no hay razon para comprar! ;)')
alertcondition(cross_01_down, title='3- cross_down', message='es un simpble script, no hay razon para vender! ;)')

/////////////////////////////////////////////////////////// INDICADORES AUXILIARES /////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////// VOLUME PROFILE ///////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
groupvolpro = " ✅✅✅✅✅✅ VOLUME PROFILE ✅✅✅✅✅✅"
volpro              = input(false, title='VOLUME PROFILE',group = groupvolpro)
vp_lookback2 = input.int(defval=400, title='Volume Lookback Depth [10-1000]', minval=100, maxval=1000,step=100, group = groupvolpro)
vp_max_bars2 = input.int(defval=50, title='Number of Bars [10-500]', step = 10, minval=10, maxval=500)
vp_bar_mult2 = input.int(defval=35, title='Bar Length Multiplier [10-100]', minval=10, maxval=100)
vp_bar_offset2 = input.int(defval=45, title='Bar Horizontal Offset [0-100]', minval=0, maxval=100)
vp_bar_width2 = input.int(defval=2, title='ancho de las barras [1-20]', minval=1, maxval=20)

// As suggested by @NXT2017
vp_delta_type2 = input.string(defval='Both', title='Delta Type', options=['Both', 'Bullish', 'Bearish'])

vp_bar_color2 = input(defval=color.rgb(255, 0, 0, 20), title='Bar Color')
vp_poc_show2 = input(defval=true, title='Show POC largo',inline = 'poclargo')
vp_poc_color2 = input(defval=color.rgb(255, 0, 0),inline = 'poclargo', title='')

///////////////////////////////////////////////////////////////////////////////////////////////////
//// VARIABLES
///////////////////////////////////////////////////////////////////////////////////////////////////
float vp_Vmax2 = 0.0
int vp_VmaxId2 = 0
int vp_N_BARS2 = vp_max_bars2
var int vp_first2 = time
vp_a_P2 = array.new_float(vp_N_BARS2 + 1, 0.0)
vp_a_V2 = array.new_float(vp_N_BARS2, 0.0)
vp_a_D2 = array.new_float(vp_N_BARS2, 0.0)
vp_a_W2 = array.new_int(vp_N_BARS2, 0)
///////////////////////////////////////////////////////////////////////////////////////////////////
//// CALCULATIONS
///////////////////////////////////////////////////////////////////////////////////////////////////
float vp_HH2 = ta.highest(high, vp_lookback2)
float vp_LL2 = ta.lowest(low, vp_lookback2)
if barstate.islast and volpro
    float vp_HL2 = (vp_HH2 - vp_LL2) / vp_N_BARS2
    for j = 1 to vp_N_BARS2 + 1 by 1
        array.set(vp_a_P2, j - 1, vp_LL2 + vp_HL2 * j)
    for i = 0 to vp_lookback2 - 1 by 1
        int Dc2 = 0
        array.fill(vp_a_D2, 0.0)
        for j = 0 to vp_N_BARS2 - 1 by 1
            float Pj2 = array.get(vp_a_P2, j)
            if low[i] < Pj2 and high[i] > Pj2 and (vp_delta_type2 == 'Bullish' ? close[i] >= open[i] : vp_delta_type2 == 'Bearish' ? close[i] <= open[i] : true)
                float Dj2 = array.get(vp_a_D2, j)
                float dDj2 = Dj2 + nz(volume[i])
                array.set(vp_a_D2, j, dDj2)
                Dc2 += 1
                Dc2
        for j = 0 to vp_N_BARS2 - 1 by 1
            float Vj2 = array.get(vp_a_V2, j)
            float Dj2 = array.get(vp_a_D2, j)
            float dVj2 = Vj2 + (Dc2 > 0 ? Dj2 / Dc2 : 0.0)
            array.set(vp_a_V2, j, dVj2)
    vp_Vmax2 := array.max(vp_a_V2)
    vp_VmaxId2 := array.indexof(vp_a_V2, vp_Vmax2)
    for j = 0 to vp_N_BARS2 - 1 by 1
        float Vj2 = array.get(vp_a_V2, j)
        int Aj2 = math.round(vp_bar_mult2 * Vj2 / vp_Vmax2)
        array.set(vp_a_W2, j, Aj2)
///////////////////////////////////////////////////////////////////////////////////////////////////
//// PLOTING
///////////////////////////////////////////////////////////////////////////////////////////////////
if barstate.isfirst
    vp_first2 := time
    vp_first2
vp_change2 = ta.change(time)
vp_x_loc2 = timenow + math.round(vp_change2 * vp_bar_offset2)
f_setup_bar2(n) =>
    x1 = vp_VmaxId2 == n and vp_poc_show2 ? math.max(time[vp_lookback2], vp_first2) : timenow + math.round(vp_change2 * (vp_bar_offset2 - array.get(vp_a_W2, n)))
    ys = array.get(vp_a_P2, n)
    line.new(x1=x1, y1=ys, x2=vp_x_loc2, y2=ys, xloc=xloc.bar_time, extend=extend.none, color=vp_VmaxId2 == n ? vp_poc_color2 : vp_bar_color2, style=line.style_solid, width=vp_bar_width2)
if barstate.islast
    for i = 0 to vp_N_BARS2 - 1 by 1
        f_setup_bar2(i)
/////////////////////////////////////////////////////////// segundo volume profile ////////////////////////

vp_lookback = (vp_lookback2/3)
vp_max_bars = vp_max_bars2
vp_bar_mult = vp_bar_mult2
vp_bar_offset = vp_bar_offset2
vp_bar_width = vp_bar_width2
vp_delta_type = vp_delta_type2
string pocinfo = 'El POC corto contempla una extencion 3 veces menor que el POC largo y esta pensado para detectar el POC de las negociaciones mas recientes'
vp_poc_show = input(defval=false, title='Show POC corto',inline = 'poccorto',tooltip = pocinfo)
vp_bar_color = vp_bar_color2
vp_poc_color = input(defval=color.rgb(255, 0, 0), inline = 'poccorto', title='')
///////////////////////////////////////////////////////////////////////////////////////////////////
//// VARIABLES
///////////////////////////////////////////////////////////////////////////////////////////////////
float vp_Vmax = 0.0
int vp_VmaxId = 0
int vp_N_BARS = vp_max_bars

var int vp_first = time

vp_a_P = array.new_float(vp_N_BARS + 1, 0.0)
vp_a_V = array.new_float(vp_N_BARS, 0.0)
vp_a_D = array.new_float(vp_N_BARS, 0.0)
vp_a_W = array.new_int(vp_N_BARS, 0)

///////////////////////////////////////////////////////////////////////////////////////////////////
//// CALCULATIONS
///////////////////////////////////////////////////////////////////////////////////////////////////
float vp_HH = ta.highest(high, vp_lookback)
float vp_LL = ta.lowest(low, vp_lookback)

if barstate.islast and volpro
    float vp_HL = (vp_HH - vp_LL) / vp_N_BARS
    for j = 1 to vp_N_BARS + 1 by 1
        array.set(vp_a_P, j - 1, vp_LL + vp_HL * j)
    for i = 0 to vp_lookback - 1 by 1
        int Dc = 0
        array.fill(vp_a_D, 0.0)
        for j = 0 to vp_N_BARS - 1 by 1
            float Pj = array.get(vp_a_P, j)
            if low[i] < Pj and high[i] > Pj and (vp_delta_type == 'Bullish' ? close[i] >= open[i] : vp_delta_type == 'Bearish' ? close[i] <= open[i] : true)
                float Dj = array.get(vp_a_D, j)
                float dDj = Dj + nz(volume[i])
                array.set(vp_a_D, j, dDj)
                Dc += 1
                Dc
        for j = 0 to vp_N_BARS - 1 by 1
            float Vj = array.get(vp_a_V, j)
            float Dj = array.get(vp_a_D, j)
            float dVj = Vj + (Dc > 0 ? Dj / Dc : 0.0)
            array.set(vp_a_V, j, dVj)
    vp_Vmax := array.max(vp_a_V)
    vp_VmaxId := array.indexof(vp_a_V, vp_Vmax)
    for j = 0 to vp_N_BARS - 1 by 1
        float Vj = array.get(vp_a_V, j)
        int Aj = math.round(vp_bar_mult * Vj / vp_Vmax)
        array.set(vp_a_W, j, Aj)

///////////////////////////////////////////////////////////////////////////////////////////////////
//// PLOTING
///////////////////////////////////////////////////////////////////////////////////////////////////
if barstate.isfirst
    vp_first := time
    vp_first
vp_change = ta.change(time)
vp_x_loc = timenow + math.round(vp_change * vp_bar_offset)

f_setup_bar(n) =>
    x1 = vp_VmaxId == n and vp_poc_show ? math.max(time[vp_lookback], vp_first) : timenow + math.round(vp_change * (vp_bar_offset - array.get(vp_a_W, n)))
    ys = array.get(vp_a_P, n)
    line.new(x1=x1, y1=ys, x2=vp_x_loc, y2=ys, xloc=xloc.bar_time, extend=extend.none, color=vp_VmaxId == n ? vp_poc_color : vp_bar_color, style=line.style_solid, width=vp_bar_width2)

if barstate.islast
    for i = 0 to vp_N_BARS - 1 by 1
        f_setup_bar(i)


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////RSI EN PANTALLA //////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


group_report = ' 💹💹💹💹  Reporte en tiempo real SENTIMIENTO  📉📉📉📉 '
string oscilador = 'muestra RSI en la misma pantalla'
multifilter = input.string("NONE", title = "ACTIVAR OSCILADOR" ,tooltip = oscilador, options = ["NONE","-RSI-"],group= "✅✅✅✅✅ MOSTRAR RSI EN EL MISMO GRAFICO ✅✅✅✅✅" )
oscLookbackLength = input.int(defval = 100, title="cantidad de barras a bloquear (PROFUNDIDAD)", minval=50, maxval=500, step= 50,group= "✅✅✅✅✅ MOSTRAR RSI EN EL MISMO GRAFICO ✅✅✅✅✅" )


group_rsi     = '🛠️🛠️ CONFIGURACION/PARAMETROS RSI EN PANTALLA 🛠️🛠️ )'
rsiLength     = input.int(14, title='RSI : Length', minval=1, group=group_rsi)
i_hideDesc   = true
tblPos       = input.string('Right', 'Position ', options=['Right', 'Left'], inline='oth',group = group_report)
bgColor      = #00000000//input.color(color.teal, 'Background', inline='COLOR', group=group_report)

ma(_source, _length, _type) => 
    switch _type
        "SMA"  => ta.sma (_source, _length)
        "EMA"  => ta.ema (_source, _length)
        "RMA"  => ta.rma (_source, _length)
        "WMA"  => ta.wma (_source, _length)
        "VWMA" => ta.vwma(_source, _length)


f_drawLabelX(_x, _y, _text, _xloc, _yloc, _color, _style, _textcolor, _size, _textalign, _tooltip) =>
    var id = label.new(_x, _y, _text, _xloc, _yloc, _color, _style, _textcolor, _size, _textalign, _tooltip)
    label.set_text(id, _text)
    label.set_tooltip(id, _tooltip)
    label.set_xy(id, _x, _y)
    label.set_textcolor(id, _textcolor)

f_getColor(_cycle) =>
    if _cycle >= 73
        #006400
    else if _cycle >= 0 and _cycle < 73
        color.from_gradient(_cycle, 0,  73, color.gray, #006400)
    else if _cycle < 0 and _cycle >= -41
        color.from_gradient(_cycle, -41, 0, #910000, color.gray)
    else if _cycle < -41
        #910000

alarm(_indi, _message) => 
    alert('the analyst : ' + syminfo.ticker + ' price (' + str.tostring(close, format.mintick) + ') : ' + _indi + ' - ' + _message , alert.freq_once_per_bar_close)

f_round(_src) =>
    str.tostring(_src, format.mintick)


i_bullColor  = input.color(color.rgb(38, 166, 154), 'Color : Bullish', inline='COLOR', group=group_report)
i_bearColor  = input.color(color.rgb(240, 83, 80), 'Bearish', inline='COLOR', group=group_report)
i_neutColor  = input.color(color.rgb(61, 72, 73), 'Neutral', inline='COLOR', group=group_report)




tooltip_rsi   = 'The Relative Strength Index (RSI) is a well versed momentum based oscillator which is used to measure the speed (velocity) as well as the change (magnitude) of directional price movements'
rsiOversold   = input.int(30, title='RSI : OverSold Theshold', minval=1, group=group_rsi)
rsiOverbought = input.int(70, title='RSI : OverBought Theshold', minval=1, group=group_rsi)
rsiSmoothing  = input.bool(false, 'Smoothing Line', inline = 'RSI', group=group_rsi)
rsiMaType     = input.string("EMA", "", options=["SMA", "EMA", "RMA", "WMA", "VWMA"], inline = 'RSI', group=group_rsi)
rsiMaLength   = input.int(14, "", inline = 'RSI', group=group_rsi)
OOffset    = input.float(0, 'Posicion del indicador (ALTURA)', step=.1, group= "✅✅✅✅✅ MOSTRAR RSI EN EL MISMO GRAFICO ✅✅✅✅✅" )
OHight      = input.float(0.6, 'Tamaño', step=.1, group="✅✅✅✅✅ MOSTRAR RSI EN EL MISMO GRAFICO ✅✅✅✅✅" )

tooltip_stoch   = 'The Stochastic Oscillator (STOCH) is a range bound momentum oscillator. Typically, the Stochastic Oscillator is used for three things; Identifying overbought and oversold levels, spotting divergences and also identifying bull and bear set ups or signals.'
//-ESTOCASTICO-       = input.bool(false, title='Enable Stochastic Visualization', group=group_stoch)
//stochVOffset    = input.float(-0.1, 'Vertical Offset', step=.1, inline = 'DISP', group=group_stoch)
//stochHight      = input.float(0.6, 'Hight', step=.1, inline = 'DISP', group=group_stoch)

tooltip_macd   = 'MACD can be used to identify aspects of a security\'s overall trend. Most notably these aspects are momentum, as well as trend direction and duration'
//-MACD-       = input.bool(false, title='Enable MACD Visualization', group=group_macd)
//macdVOffset    = input.float(-0.1, 'Vertical Offset', step=.1, inline = 'DISP', group=group_macd)
//macdHight      = input.float(0.6, 'Hight', step=.1, inline = 'DISP', group=group_macd)





textColor    = color.rgb(255, 255, 255)

// -Calculations ================================================================================ //

source   = close
nzVolume = nz(volume)
    
// Momentum : Relative Strength Index (RSI)

rsiValue = ta.rsi(source, rsiLength)
rsiChg = ta.change(rsiValue) > 0 ? ') and growing (previous rsi(' + str.tostring(rsiValue[1], '#.##') + ')' : ') and falling (previous rsi(' + str.tostring(rsiValue[1], '#.##') + ')'
rsiSmooth = rsiSmoothing ? ma(rsiValue, rsiMaLength, rsiMaType) : na

//------------------------------------------------------------------------------
// Momentum : Stochastic Oscillator

var stochText = ''

//------------------------------------------------------------------------------
// Momentum : MACD Oscillator



pmacd = (close / ta.ema(close, 144) - 1) * 100
ror = ta.change(close, 144) / close[144] * 100
accDist = close == high and close == low or high == low ? 0 : (2 * close - low - high) / (high - low)


//------------------------------------------------------------------------------
// Report

//table.merge_cells(table_id, start_column, start_row, end_column, end_row)
//table.cell(table_id, column, row, text, width, height, text_color, text_halign, text_valign, text_size, bgcolor, tooltip, text_font_family)
header = 'Technical Analysis Report\n' + syminfo.description + ' - TimeFrame (' + timeframe.period + ')'
var table taTable = na
if i_hideDesc
    taTable := table.new(tblPos == 'Right' ? position.top_right : position.bottom_left, 4, 37, border_width = 2) 
else
    taTable := table.new(tblPos == 'Right' ? position.top_right : position.bottom_left, 4, 37, frame_color=bgColor, frame_width=2) 

if barstate.islast

    if not i_hideDesc
        table.cell(taTable, 0, 0, bgcolor=bgColor)
        table.cell(taTable, 1, 0, bgcolor=bgColor)
        table.cell(taTable, 2, 0, header, text_color=chart.fg_color, text_halign=text.align_right, text_size=textSize, bgcolor=bgColor)

        table.cell(taTable, 0, 1, height=1, bgcolor=bgColor)
        table.cell(taTable, 1, 1, height=1, bgcolor=bgColor)
        table.cell(taTable, 2, 1, height=1, bgcolor=bgColor)

    //------------------------------------------------------------------------------
    if not i_hideDesc
        table.cell(taTable, 2, 2, bgcolor=bgColor)

    //------------------------------------------------------------------------------
    // Trend : Moving Averagres


    
    if not i_hideDesc
        table.cell(taTable, 0, 6, height=1, bgcolor=bgColor)
        table.cell(taTable, 1, 6, height=1, bgcolor=bgColor)
        table.cell(taTable, 2, 6, height=1, bgcolor=bgColor)


        
    //------------------------------------------------------------------------------
    

    //------------------------------------------------------------------------------
    // Momentum
    
    table.cell(taTable, 0, 14, 'SENTIMIENTO', text_color=chart.fg_color, text_halign=text.align_center, text_size=textSize, bgcolor=bgColor)
    table.cell(taTable, 1, 14, bgcolor=bgColor)
    table.merge_cells(taTable, 0, 14, 1, 14)

    if not i_hideDesc
        table.cell(taTable, 2, 14, bgcolor=bgColor)

    //------------------------------------------------------------------------------
    // Momentum : Relative Strength Index (RSI)

    [rsi_bias, rsi_color] = if rsiValue >= 50
        if rsiValue > rsiOverbought
            ['bullish (overbought)', color.new(i_bullColor, 30)]
        else if rsiValue > 60
            ['bullish', color.new(i_bullColor, 10)]
        else
            ['neutral', i_neutColor]
    else
        if rsiValue < rsiOversold
            ['bearish (oversold)', color.new(i_bearColor, 30)]
        else if rsiValue < 40
            ['bearish', color.new(i_bearColor, 10)]
        else
            ['neutral', i_neutColor]

    table.cell(taTable, 0, 15, 'RSI', text_color=textColor, text_halign=text.align_left, text_size=textSize, bgcolor=rsi_color, tooltip = tooltip_rsi)
    table.cell(taTable, 1, 15, rsi_bias, text_color=textColor, text_halign=text.align_left, text_size=textSize, bgcolor=rsi_color, tooltip = 'rsi(' + str.tostring(rsiValue, '#.##') + rsiChg)
    if not i_hideDesc
        table.cell(taTable, 2, 15, 'rsi(' + str.tostring(rsiValue, '#.##') + rsiChg, text_color=textColor, text_halign=text.align_left, text_size=textSize, bgcolor=rsi_color)

        table.cell(taTable, 0, 16, height=1, bgcolor=bgColor)
        table.cell(taTable, 1, 16, height=1, bgcolor=bgColor)
        table.cell(taTable, 2, 16, height=1, bgcolor=bgColor)

    //------------------------------------------------------------------------------
    // Momentum : Stochastic Oscillator


    
    
        table.cell(taTable, 0, 20, height=1, bgcolor=bgColor)
        table.cell(taTable, 1, 20, height=1, bgcolor=bgColor) 
        table.cell(taTable, 2, 20, height=1, bgcolor=bgColor)

    //------------------------------------------------------------------------------
    // Momentum : MACD Oscillator

    
    

        table.cell(taTable, 0, 24, height=1, bgcolor=bgColor)
        table.cell(taTable, 1, 24, height=1, bgcolor=bgColor)
        table.cell(taTable, 2, 24, height=1, bgcolor=bgColor)
    
    //------------------------------------------------------------------------------



    

var a_lines       = array.new_line()
var a_hist        = array.new_box()

priceHighest      = ta.highest(high, oscLookbackLength)
priceLowest       = ta.lowest (low , oscLookbackLength)
priceChangeRate   = (priceHighest - priceLowest) / priceHighest

oscHighest        = 100//ta.highest(osc, oscLookbackLength)


if barstate.islast 
    if array.size(a_lines) > 0
        for i = 1 to array.size(a_lines)
            line.delete(array.shift(a_lines))
    
    if array.size(a_hist) > 0
        for i = 1 to array.size(a_hist)
            box.delete(array.shift(a_hist))

    if multifilter == "-RSI-"
        array.push(a_hist , box.new (bar_index[oscLookbackLength], priceHighest * (1 - priceChangeRate * -OOffset)   * (1 - rsiOverbought / -oscHighest * -priceChangeRate * -OHight), 
                                     bar_index                   , priceHighest * (1 - priceChangeRate * -OOffset)   * (1 - rsiOverbought / -oscHighest * -priceChangeRate * -OHight), color.new(color.red  , 75), 3))
        array.push(a_hist , box.new (bar_index[oscLookbackLength], priceHighest * (1 - priceChangeRate * -OOffset)   * (1 - rsiOversold   / -oscHighest * -priceChangeRate * -OHight), 
                                     bar_index                   , priceHighest * (1 - priceChangeRate * -OOffset)   * (1 - rsiOversold   / -oscHighest * -priceChangeRate * -OHight), color.new(color.green, 75), 3))
        f_drawLabelX(bar_index + 1,                                priceHighest * (1 - priceChangeRate * -OOffset)   * (1 - rsiOversold   / -oscHighest * -priceChangeRate * -OHight), 'RSI', xloc.bar_index, yloc.price, #00000000, label.style_label_left, chart.fg_color, size.tiny, text.align_right, str.tostring(rsiValue, '#.##'))



    if multifilter == "-MACD-"
        f_drawLabelX(bar_index + 1                               , priceHighest * (1 - priceChangeRate * -OOffset), 'MACD', xloc.bar_index, yloc.price, #00000000, label.style_label_left, chart.fg_color, size.tiny, text.align_right, '')//'macd : ' + str.tostring(macdLine, '#.##') + '\nsignal : ' + str.tostring(signalLine, '#.##'))

    for barIndex = 0 to oscLookbackLength - 1
        if array.size(a_lines) < 500
          
            if multifilter =="-RSI-"
                array.push(a_lines, line.new(bar_index[barIndex], priceHighest * (1 - priceChangeRate * -OOffset) * (1 - rsiValue[barIndex]        / -oscHighest * -priceChangeRate * -OHight), 
                                         bar_index[barIndex + 1], priceHighest * (1 - priceChangeRate * -OOffset) * (1 - rsiValue[barIndex + 1]    / -oscHighest * -priceChangeRate * -OHight), xloc.bar_index, extend.none, #7e57c2   , line.style_solid, 1))
                if rsiSmoothing
                    array.push(a_lines, line.new(bar_index[barIndex], priceHighest * (1 - priceChangeRate * -OOffset) * (1 - rsiSmooth[barIndex]   / -oscHighest * -priceChangeRate * -OHight), 
                                             bar_index[barIndex + 1], priceHighest * (1 - priceChangeRate * -OOffset) * (1 - rsiSmooth[barIndex + 1]   / -oscHighest * -priceChangeRate * -OHight), xloc.bar_index, extend.none, color.yellow   , line.style_solid, 1))




////////////////////////////////////// PARAMETROS PARA LA VISUALIZACION DE LA TABLA DE ADX AND DI ///////////////////
lenI = 14
th = 20

var string tendencia = ""
var string fuerza = ""
var string girado = ""

TrueRange = math.max(math.max(high - low, math.abs(high - nz(close[1]))), math.abs(low - nz(close[1])))
DirectionalMovementPlus = high - nz(high[1]) > nz(low[1]) - low ? math.max(high - nz(high[1]), 0) : 0
DirectionalMovementMinus = nz(low[1]) - low > high - nz(high[1]) ? math.max(nz(low[1]) - low, 0) : 0

SmoothedTrueRange = 0.0
SmoothedTrueRange := nz(SmoothedTrueRange[1]) - nz(SmoothedTrueRange[1]) / lenI + TrueRange

SmoothedDirectionalMovementPlus = 0.0
SmoothedDirectionalMovementPlus := nz(SmoothedDirectionalMovementPlus[1]) - nz(SmoothedDirectionalMovementPlus[1]) / lenI + DirectionalMovementPlus

SmoothedDirectionalMovementMinus = 0.0
SmoothedDirectionalMovementMinus := nz(SmoothedDirectionalMovementMinus[1]) - nz(SmoothedDirectionalMovementMinus[1]) / lenI + DirectionalMovementMinus

DIPlus = SmoothedDirectionalMovementPlus / SmoothedTrueRange * 100
DIMinus = SmoothedDirectionalMovementMinus / SmoothedTrueRange * 100
DX = math.abs(DIPlus - DIMinus) / (DIPlus + DIMinus) * 100
ADX = ta.sma(DX, lenI)


if ta.crossover(DIPlus, DIMinus)
    tendencia := "ALCISTA"
if ta.crossunder(DIPlus, DIMinus)
    tendencia := "BAJISTA"
if ADX < 20
    fuerza := "indefinida"
if ADX >= 20 and ADX < 25
    fuerza := "DEBIL"
if ADX >= 25 and ADX < 50
    fuerza := "FUERTE"
if ADX >= 50
    fuerza := "EXTREMA"
if ADX > ADX[2]
    girado :="↑"
if ADX < ADX[2]
    girado := "↓"


// Crear la tabla
//var adxtable = table.new(position.middle_right , 1, 3, border_width =1) 

table.cell(taTable,0, 25, girado + " " + "ADX" + " " + "and DI", text_color = color.rgb(255, 255, 255, 20),text_halign=text.align_left, text_size = size.small)
table.cell(taTable, 1, 25, tendencia + " " + fuerza, text_color = color.rgb(255, 255, 255, 30),text_halign=text.align_left, text_size = size.small)



///////////////////////////////////////////////////////////////////////////////////////////////////
//// THE BOX /////////// LA CAJA //////////////// ESTRATEGIA DE APERTURA
///////////////////////////////////////////////////////////////////////////////////////////////////
show_sesa = true
gorupbox  =  "📦📦📦 Estrategia de apertura (La Caja) 📦📦📦"
sesa_txt = input('THE BOX', '', inline = 'box',group = gorupbox)
sesa_css = input.color(color.rgb(255, 255, 255), 'Color', inline = 'box',group = gorupbox)
bg_transp = input.float(80, 'Transparencia', inline =  'box',group = gorupbox)

sesa_ses = input.session('1430-1600', '', inline = 'sesa')
sesa_ses2 = input.session('1000-1200', '', inline = 'sesa', group = 'ventana operativa [adaptar segun zona horaria por defecto UTC 2] duracion recomendada 2hs.')
t1 = time(timeframe.period, sesa_ses2)
bgcolor(t1 and sesa_range? color.rgb(83, 228, 228, 80) : na)

//Timezones
tz_incr = input.int(2, 'UTC (+/-)', group = 'Timezone')
//Ranges Options
show_outline = true
show_txt = true
//-----------------------------------------------------------------------------}
//Functions
//-----------------------------------------------------------------------------{
n = bar_index
get_range(session, session_name, session_css)=>
    var t = 0 
    var max = high
    var min = low
    var med =0.0
    var box bx = na
    var label lbl = na 
    if session > session[1]
        t := time
        max := high
        min := low

        bx := box.new(n, max, n, min
          , bgcolor = color.new(session_css, bg_transp)
          , border_color = show_outline ? session_css : na
          , border_style = line.style_dotted)

        if show_txt
            lbl := label.new(t, max, session_name, xloc = xloc.bar_time, textcolor = session_css, style = label.style_label_down, color = color.new(color.white, 100), size = size.tiny)

    if session and session == session[1]

        max := math.max(high, max)
        min := math.min(low, min)
        med := min + (max - min)/2
        box.set_top(bx, max)
        box.set_rightbottom(bx, n, min)

        if show_txt
            label.set_xy(lbl, int(math.avg(t, time)), max)
//-----------------------------------------------------------------------------}
//Sessions
//-----------------------------------------------------------------------------{
tf = timeframe.period
var tz = str.format('UTC{0}{1}', tz_incr >= 0 ? '+' : '-', math.abs(tz_incr))
is_sesa = math.sign(nz(time(tf, sesa_ses, tz)))
if show_sesa and sesa_range
    get_range(is_sesa, sesa_txt, sesa_css)

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////modulo de divergencias /////////////////////////////////////////////////////////////////////////////////
string infodivergen =' version beta, muestra divergencias filtrando posibles ruidos mediante la configuracion de una media movil exponencial'
diver =input(false, title = "Mostrar divergencias RSI",tooltip = infodivergen,group = "🛠️🛠️🛠️🛠️CONFIGURACION RSI (filtro PUPUPU)🛠️🛠️🛠️🛠️")
string infodiv ='muestra las divergencias bajistas cuando el precio se encuentra sobre la ema y las alcistas cuando el precios de encuentra por debajo de la ema'
longi = input(26, title='Longitud EMA',tooltip = infodiv,group = "🛠️🛠️🛠️🛠️CONFIGURACION RSI (filtro PUPUPU)🛠️🛠️🛠️🛠️")

// arrays para mantener los puntos maximos y minimos de cada zona
var activo_puntos_maximos_x = array.new_int()
var activo_puntos_maximos_y = array.new_float()
var activo_puntos_minimos_x = array.new_int()
var activo_puntos_minimos_y = array.new_float()
var rsi_puntos_maximos_y = array.new_float()
var rsi_puntos_minimos_y = array.new_float()

var lineas = array.new_line()
borrar_lineas() =>
    c = array.size(lineas)
    if c > 0
        for r = 0 to c - 1 by 1
            line.delete(array.get(lineas, r))
        array.clear(lineas)
if diver

// calculos para obtener la ema y la distancia hasta la ema
    ema = ta.ema(close, longi)
    dist = math.abs(close - ema)
    porcentajed = dist * 100 / close
    mm_porcentaje = ta.ema(porcentajed,240)

// calculo para obtener el RSI
// inicialización de las variables para mantener los maximos y minimos por zona
    activo_ultimo_maximo_x = 0
    activo_ultimo_maximo_y = 0.0
    rsi_ultimo_maximo_y = 0.0

    activo_ultimo_minimo_x = 0
    activo_ultimo_minimo_y = 99999999999999.9
    rsi_ultimo_minimo_y = 0.0



// inicializamos las variables para saber si tenemos que buscar maximos o minimos
    buscando_maximos = ema > ema[1] and close > ema
    buscando_minimos = ema < ema[1] and close < ema

// en la última vela
    if barstate.islast
        array.clear(activo_puntos_maximos_x)
        array.clear(activo_puntos_maximos_y)
        array.clear(activo_puntos_minimos_x)
        array.clear(activo_puntos_minimos_y)
        array.clear(rsi_puntos_maximos_y)
        array.clear(rsi_puntos_minimos_y)
        for pos = 0 to 900 by 1
            if buscando_maximos
                if close[pos] > ema[pos] and porcentajed[pos] > mm_porcentaje[pos]  // si se sigue cumpliendo la condicion de buscar maximos
                    if close[pos] > activo_ultimo_maximo_y  // si encontramos un nuevo maximo
                    // mantenemos el nuevo maximo
                        activo_ultimo_maximo_y := close[pos]
                        activo_ultimo_maximo_x := time[pos]
                        rsi_ultimo_maximo_y := rsi[pos]
                        rsi_ultimo_maximo_y


                if ema[pos] < ema[pos + 1] and close[pos] < ema[pos]  // si la condicion ya no se cumple, debemos comenzar a buscar minimos
                    if activo_ultimo_maximo_x > 0
                    // agregamos el último maximo al array de maximos
                        array.push(activo_puntos_maximos_x, activo_ultimo_maximo_x)
                        array.push(activo_puntos_maximos_y, activo_ultimo_maximo_y)
                        array.push(rsi_puntos_maximos_y, rsi_ultimo_maximo_y)

                // inicializamos las variables para la proxima vez que tengamos que buscar nuevos maximos
                    activo_ultimo_maximo_x := 0
                    activo_ultimo_maximo_y := 0.0
                    rsi_ultimo_maximo_y := 0.0

                //  establecemos que ahora necesitamos buscar nuevos minimos
                    buscando_maximos := false
                    buscando_minimos := true
                    buscando_minimos

            if buscando_minimos
                if close[pos] < ema[pos] and porcentajed[pos] > mm_porcentaje[pos]  // si se sigue cumpliendo la condición de buscar nuevos minimos
                    if close[pos] < activo_ultimo_minimo_y  // si encontramos u nuevo minimo
                    // mantenemos el nuevo minimo
                        activo_ultimo_minimo_y := close[pos]
                        activo_ultimo_minimo_x := time[pos]
                        rsi_ultimo_minimo_y := rsi[pos]
                        rsi_ultimo_minimo_y

                if ema[pos] > ema[pos + 1] and close[pos] > ema[pos]  // si la condicion ya no se cumple, debemos comenzar a buscar maximos
                    if activo_ultimo_minimo_x > 0
                    // agregamos el último minimo al array de minimos
                        array.push(activo_puntos_minimos_x, activo_ultimo_minimo_x)
                        array.push(activo_puntos_minimos_y, activo_ultimo_minimo_y)
                        array.push(rsi_puntos_minimos_y, rsi_ultimo_minimo_y)

                // inicializamos las variables para la proxima vez que tengamos que buscar nuevos minimos
                    activo_ultimo_minimo_x := 0
                    activo_ultimo_minimo_y := 99999999999999.9
                    rsi_ultimo_minimo_y := 99999999999999.9

                // establecemos que ahora necesitamos buscar nuevmos maximos
                    buscando_maximos := true
                    buscando_minimos := false
                    buscando_minimos

    // recorremos todo los puntos maximos para unirlos con una linea si es que cumplen con la condición de divergencia
        for r = 0 to array.size(activo_puntos_maximos_x) - 2 by 1
            ax1 = array.get(activo_puntos_maximos_x, r)
            ay1 = array.get(activo_puntos_maximos_y, r)
            ax2 = array.get(activo_puntos_maximos_x, r + 1)
            ay2 = array.get(activo_puntos_maximos_y, r + 1)

            ry1 = array.get(rsi_puntos_maximos_y, r)
            ry2 = array.get(rsi_puntos_maximos_y, r + 1)

            l = line.new(ax1, ay1, ax2, ay2, xloc=xloc.bar_time, color=ay1 > ay2 and ry1 < ry2 ? color.rgb(238, 13, 13) : na, style = line.style_solid, width=3)
            array.push(lineas, l)

    // recorremos todo los puntos minimos para unirlos con una linea si es que cumplen con la condición de divergencia [este indicador fue realizado por Caifas81]
        for r = 0 to array.size(activo_puntos_minimos_x) - 2 by 1
            ax1 = array.get(activo_puntos_minimos_x, r)
            ay1 = array.get(activo_puntos_minimos_y, r)
            ax2 = array.get(activo_puntos_minimos_x, r + 1)
            ay2 = array.get(activo_puntos_minimos_y, r + 1)

            ry1 = array.get(rsi_puntos_minimos_y, r)
            ry2 = array.get(rsi_puntos_minimos_y, r + 1)

            l = line.new(ax1, ay1, ax2, ay2, xloc=xloc.bar_time, color=ay1 < ay2 and ry1 > ry2 ? color.rgb(23, 175, 41) : na, style = line.style_solid, width=3)
            array.push(lineas, l)



